Start test section vessel
-------------------------

>> Start Test J.0 Checking _Section_leaf_node_base {
J.1.0=1 New _Section_leaf_node_base section_leaf_node_base = _Section_leaf_node_base()
J.1.1=1 Verifying default constructor. Checkout whether section_leaf_node_base._next is nullptr: 0 ,expected nullptr; Checkout whether section_leaf_node_base._prev is nullptr: 0 ,expected nullptr;
J.1.2=1 Construct Val by pointers to _Section_leaf_node_base: `_Section_leaf_node_base section_leaf_node_base2(&section_leaf_node_base, &section_leaf_node_base);`
J.1.3=1 Verifying constructor. section_leaf_node_base2._prev: 0x7ffeefbff770, expected 0x7ffeefbff770. ._next: 0x7ffeefbff770, expected 0x7ffeefbff770
} succeeded(4/4). Pass test J.1.

>> Start Test J.1 Checking _Section_tree_node_base {
J.2.0=1 New _Section_tree_node_base section_tree_node_base = _Section_tree_node_base()
J.2.1=1 Verifying default constructor. section_tree_node_base._left: 0, expected nullptr. section_tree_node_base._right:0, expected nullptr. section_tree_node_base._parent: 0, expected nullptr.
J.2.2=1 Construct section_tree_node_base2 by pointers to ._Section_tree_node_base: `_Section_tree_node_base section_tree_node_base2(&tb, &tb, &tb);`
J.2.3=1 Verifying constructor. section_node_base2._parent: 0x7ffeefbff740, expected 0x7ffeefbff740. ._left: 0x7ffeefbff740, expected 0x7ffeefbff740. ._right: 0x7ffeefbff740, expected: 0x7ffeefbff740
} succeeded(4/4). Pass test J.2.

>> Start Test J.2 Checking _Section_node_header {
J.3.0=1 New _Section_node_header, show its ._parent: 0, ._right: 0x7ffeefbff600, ._left: 0x7ffeefbff600
J.3.1=1 Verify section_node_header's ._size: 0, .node_count: 0, both expected 0
J.3.2=1 New _Section_node_header section_node_header2 constructed by section_node_header.
J.3.3=1 Checkout whether section_node_header2's ._left: 0x7ffeefbff640, ._right: 0x7ffeefbff640, this: 0x7ffeefbff640, expected equal.
J.3.4=1 New _Section_node_header section_node_header4 cannot constructed by const section_node_header&.
J.3.5=1 New _Section_node_header section_node_header5 connected section_node_header forming a circle.
J.3.6=1 New _Section_node_header section_node_header6 constructed by section_node_header5.
J.3.7=1 Check whether section_node_header and section_node_header6 forms a circle, section_node_header's this: 0x7ffeefbff600, ._left: 0x7ffeefbff6d0, ._right: 0x7ffeefbff6d0, section_node_header6's this: 0x7ffeefbff6d0, ._left: 0x7ffeefbff600, ._right: 0x7ffeefbff600
J.3.8=1 Check whether section_node_header5 is reconstructed by default. section_node_header5' this: 0x7ffeefbff680, ._left: 0x7ffeefbff680, ._right: 0x7ffeefbff680
} succeeded(9/9). Pass test J.3.

>> Start Test J.3 Checking _Section_leaf_node: {
J.4.0=1 Testing _Section_leaf_node, new _Section_leaf_node.
J.4.1=1 1Test whether successfully default construct inherit from _Section_tree_node_base. leaf_node._parent: 0, expected nullptr. leaf_node._left: 0, expected nullptr. .right: 0, expected nullptr.
J.4.2=1 Test whether successfully default construct inherit from _Section_leaf_node_base. leaf_node._prev: 0, expected nullptr. leaf_node._next: 0, expected nullptr.
J.4.3=1 Test whether ._pair member works.
J.4.4=1 Construct pr2 by leaf_node._valptr(), expected *pair<int, int> type. pr2->first = 100, pr2->second = 101, expected (100, 101).
J.4.5=1 Test whether pr2 isn't const, modify it and now, pr2->first = 200, pr2->second = 201, expected (200, 201).
J.4.6=1 Construct pr3 by static_cast<const ...>(leaf_node)._valptr(), expected pr3 as const pair<int, int>. pr3->first = 200, pr3->second = 201, expected (200, 201).
J.4.7=1 pr3 is const, verifying.
} succeeded(8/8). Pass test J.4.

>> Start Test J.4 Checking _Section_tree_node {
J.5.0=1 Testing default constructor: `_Section_tree_node<int, int> section_tree_node;`
J.5.1=1 Testing section_tree_node's_right: 0, expected 0
J.5.2=1 Testing section_tree_node's ._has_mid: 0, expected false.
J.5.3=1 Testing section_tree_node's ._Is_leaf: 0, expected false
J.5.4=1 Testing section_tree_node's _sum: 0, expected 0.
J.5.5=1 Testing section_tree_node successfully inherit from _Section_tree_node_base, show its _left: 0, expected nullptr. ._right: 0, expected nullptr. ._parent: 0, expected nullptr.
} succeeded(6/6). Pass test J.5.

>> Start Test J.5 Checking section {
J.6.0=1 New section<int, pair<int, int> > sec
J.6.1=1 Checking sec's header.
J.6.2=1 Insert key and value, expected no error
J.6.3=1 Insert another
J.6.4=1 test swap
J.6.5=1 insert 3
J.6.6=1 insert 4
J.6.7=1 
J.6.8=1 
J.6.9=1 
J.6.10=1 
J.6.11=1 
J.6.12=1 
J.6.13=1 
J.6.14=1 
J.6.15=1 
J.6.16=1 
J.6.17=1 
J.6.18=1 
J.6.19=1 
J.6.20=1 
J.6.21=1 
J.6.22=1 
J.6.23=1 check key is 0
J.6.24=1 check key is 1
J.6.25=1 check key is 2
J.6.26=1 check key is 3
J.6.27=1 check key is 4
J.6.28=1 check key is 5
J.6.29=1 check key is 6
J.6.30=1 check key is 7
J.6.31=1 check key is 8
J.6.32=1 check key is 9
J.6.33=1 check key is 10
J.6.34=1 check key is 11
J.6.35=1 check key is 12
J.6.36=1 check key is 13
J.6.37=1 check key is 14
J.6.38=1 check key is 15
J.6.39=1 check key is 16
J.6.40=1 check key is 17
J.6.41=1 check key is 18
J.6.42=1 check key is 19
J.6.43=1 check key is 20
J.6.44=1 check key is 21
J.6.45=1 check key is 22
J.6.46=1 check key is 23
J.6.47=1 check key is 24
J.6.48=1 check key is 25
J.6.49=1 check key is 26
J.6.50=1 check key is 27
J.6.51=1 check key is 28
J.6.52=1 check key is 29
J.6.53=1 check key is 30
J.6.54=1 check key is 31
J.6.55=1 check key is 32
J.6.56=1 check key is 33
J.6.57=1 check key is 34
J.6.58=1 check key is 35
J.6.59=1 check key is 36
J.6.60=1 check key is 37
J.6.61=1 check key is 38
J.6.62=1 check key is 39
J.6.63=1 check key is 40
J.6.64=1 check key is 41
J.6.65=1 check key is 42
J.6.66=1 check key is 43
J.6.67=1 check key is 44
J.6.68=1 check key is 45
J.6.69=1 check key is 46
J.6.70=1 check key is 47
J.6.71=1 check key is 48
J.6.72=1 check key is 49
J.6.73=1 
J.6.74=1 
J.6.75=1 
J.6.76=1 
J.6.77=1 
J.6.78=1 
J.6.79=1 
J.6.80=1 
J.6.81=1 
J.6.82=1 
J.6.83=1 
J.6.84=1 
J.6.85=1 
J.6.86=1 
J.6.87=1 
J.6.88=1 
J.6.89=1 
J.6.90=1 
J.6.91=1 
J.6.92=1 
J.6.93=1 
J.6.94=1 
J.6.95=1 
J.6.96=1 
J.6.97=1 
J.6.98=1 
J.6.99=1 
J.6.100=1 
J.6.101=1 
J.6.102=1 
J.6.103=1 
J.6.104=1 
J.6.105=1 
J.6.106=1 
J.6.107=1 
J.6.108=1 
J.6.109=1 
J.6.110=1 
J.6.111=1 
J.6.112=1 
J.6.113=1 
J.6.114=1 
J.6.115=1 
J.6.116=1 
J.6.117=1 
J.6.118=1 
J.6.119=1 
J.6.120=1 
J.6.121=1 
J.6.122=1 
J.6.123=1 
J.6.124=1 
J.6.125=1 
J.6.126=1 
J.6.127=1 
J.6.128=1 
J.6.129=1 
J.6.130=1 
J.6.131=1 
J.6.132=1 
J.6.133=1 
J.6.134=1 
J.6.135=1 
J.6.136=1 
J.6.137=1 
J.6.138=1 
J.6.139=1 
J.6.140=1 
J.6.141=1 
J.6.142=1 
J.6.143=1 
J.6.144=1 
J.6.145=1 
J.6.146=1 
J.6.147=1 
J.6.148=1 
J.6.149=1 
J.6.150=1 
J.6.151=1 
J.6.152=1 
J.6.153=1 
J.6.154=1 
J.6.155=1 
J.6.156=1 
J.6.157=1 
J.6.158=1 
J.6.159=1 
J.6.160=1 
J.6.161=1 
J.6.162=1 
J.6.163=1 
J.6.164=1 
J.6.165=1 
J.6.166=1 
J.6.167=1 
J.6.168=1 
J.6.169=1 
J.6.170=1 
J.6.171=1 
J.6.172=1 
J.6.173=1 
J.6.174=1 
J.6.175=1 
J.6.176=1 
J.6.177=1 
J.6.178=1 
J.6.179=1 
J.6.180=1 
J.6.181=1 
J.6.182=1 
J.6.183=1 
J.6.184=1 
} succeeded(185/185). Pass test J.6.

-----------------------
End test section vessel, succeeded part(6/6)
